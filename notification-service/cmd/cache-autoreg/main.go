// cmd/cache-autoreg/main.go
package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"golang.org/x/tools/go/packages"
)

type item struct {
	PkgPath string
	PkgName string
	Type    string
}

func findModuleRoot() string {
	dir, _ := os.Getwd()
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return ""
		}
		dir = parent
	}
}

func main() {
	root := findModuleRoot()
	if root == "" {
		log.Fatal("cache-autoreg: go.mod not found")
	}

	cfg := &packages.Config{
		Mode: packages.NeedName |
			packages.NeedFiles |
			packages.NeedSyntax |
			packages.NeedTypes |
			packages.NeedTypesInfo |
			packages.NeedModule,
		Dir: root,
	}

	pkgs, err := packages.Load(cfg, "./...")
	if err != nil {
		log.Fatal(err)
	}

	items := discover(pkgs)
	if len(items) == 0 {
		log.Println("cache-autoreg: no items found, file not generated")
		return
	}

	code := generate("di", items)

	out := filepath.Join(root, "pkg", "di", "cache_autoreg.generated.go")
	if err := os.MkdirAll(filepath.Dir(out), 0o755); err != nil {
		log.Fatal(err)
	}
	if err := os.WriteFile(out, code, 0o644); err != nil {
		log.Fatal(err)
	}
	log.Printf("cache-autoreg: generated %s (%d types)\n", out, len(items))
}

func discover(pkgs []*packages.Package) []item {
	seen := make(map[string]bool)
	var res []item

	for _, p := range pkgs {
		if p.Module == nil || p.Module.Path == "" {
			continue
		}
		info := p.TypesInfo

		for id, obj := range info.Defs {
			if obj == nil || id == nil || id.Name != "RegisterForCache" {
				continue
			}
			fn, ok := obj.(*types.Func)
			if !ok {
				continue
			}
			sig, ok := fn.Type().(*types.Signature)
			if !ok {
				continue
			}
			recv := sig.Recv()
			if recv == nil {
				continue
			}
			rt := recv.Type()
			if ptr, ok := rt.(*types.Pointer); ok {
				rt = ptr.Elem()
			}
			named, ok := rt.(*types.Named)
			if !ok {
				continue
			}
			objType := named.Obj()
			if objType == nil || objType.Pkg() == nil {
				continue
			}
			pkgPath := objType.Pkg().Path()
			typeName := objType.Name()

			key := pkgPath + "::" + typeName
			if seen[key] {
				continue
			}
			seen[key] = true

			res = append(res, item{
				PkgPath: pkgPath,
				PkgName: objType.Pkg().Name(),
				Type:    typeName,
			})
		}

		for _, f := range p.Syntax {
			_ = f
			_ = ast.File{}
		}
	}

	sort.Slice(res, func(i, j int) bool {
		if res[i].PkgPath == res[j].PkgPath {
			return res[i].Type < res[j].Type
		}
		return res[i].PkgPath < res[j].PkgPath
	})

	return res
}

func generate(targetPkg string, items []item) []byte {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, "// Code generated by cache-autoreg; DO NOT EDIT.")
	fmt.Fprintln(&buf, "//go:build !nocacheautoreg")
	fmt.Fprintf(&buf, "package %s\n\n", targetPkg)

	aliases := make(map[string]string) // path -> alias
	var impOrder []string
	for _, it := range items {
		if _, ok := aliases[it.PkgPath]; ok {
			continue
		}
		alias := aliasFor(it.PkgPath, aliases)
		aliases[it.PkgPath] = alias
		impOrder = append(impOrder, it.PkgPath)
	}
	sort.Strings(impOrder)

	fmt.Fprintln(&buf, "import (")
	fmt.Fprintln(&buf, `	_ "notification-service-api/pkg/cache"`)
	for _, path := range impOrder {
		if path == "notification-service-api/pkg/cache" {
			continue
		}

		fmt.Fprintf(&buf, "	%s %q\n", aliases[path], path)
	}
	fmt.Fprintln(&buf, ")")
	fmt.Fprintln(&buf, "")
	fmt.Fprintln(&buf, "func init() {")
	for _, it := range items {
		alias := aliases[it.PkgPath]
		if alias == "cache" && it.Type == "Registrable" {
			continue
		}

		fmt.Fprintf(&buf, "	(%s.%s{}).RegisterForCache()\n", alias, it.Type)
	}
	fmt.Fprintln(&buf, "}")

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes()
	}
	return formatted
}

func aliasFor(path string, used map[string]string) string {
	base := filepath.Base(path)
	base = strings.ReplaceAll(base, "-", "_")
	alias := base
	i := 1
	for containsValue(used, alias) {
		i++
		alias = fmt.Sprintf("%s_%d", base, i)
	}
	return alias
}

func containsValue(m map[string]string, v string) bool {
	for _, x := range m {
		if x == v {
			return true
		}
	}
	return false
}
